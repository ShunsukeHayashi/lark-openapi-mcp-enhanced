# MCP Custom Processors Definition
# ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼å®šç¾©

version: "1.0"
metadata:
  description: "Custom processors for EC operation workflows"
  created: "2025-01-18"

# ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼å®šç¾©
processors:
  # ========================================
  # åœ¨åº«åˆ†æãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼
  # ========================================
  inventory_analyzer:
    description: "åœ¨åº«ãƒ¬ãƒ™ãƒ«ã‚’åˆ†æã—åˆ†é¡"
    inputs:
      products:
        type: "array"
        schema:
          fields:
            ğŸ“Šç¾åœ¨åº«: "integer"
            ğŸ“ˆ30æ—¥è²©å£²æ•°: "integer"
      threshold:
        type: "integer"
        default: 30
    
    logic: |
      function analyze(products, threshold) {
        const results = {
          critical: [],
          warning: [],
          normal: [],
          excess: []
        };
        
        products.forEach(product => {
          const stock = product.fields['ğŸ“Šç¾åœ¨åº«'] || 0;
          const monthlySales = product.fields['ğŸ“ˆ30æ—¥è²©å£²æ•° (æ•°å€¤)'] || 0;
          const dailySales = monthlySales / 30;
          const daysOfStock = dailySales > 0 ? stock / dailySales : 999;
          
          const item = {
            name: product.fields['ğŸ“å•†å“å'][0].text,
            stock: stock,
            sales: monthlySales,
            daysOfStock: Math.round(daysOfStock),
            record_id: product.record_id
          };
          
          if (daysOfStock < 7) {
            results.critical.push(item);
          } else if (daysOfStock < 14) {
            results.warning.push(item);
          } else if (daysOfStock < threshold) {
            results.normal.push(item);
          } else {
            results.excess.push(item);
          }
        });
        
        return results;
      }
    
    outputs:
      critical:
        type: "array"
        description: "7æ—¥ä»¥å†…ã«åœ¨åº«åˆ‡ã‚Œãƒªã‚¹ã‚¯ã®ã‚ã‚‹å•†å“"
      warning:
        type: "array"
        description: "14æ—¥ä»¥å†…ã«è¦æ³¨æ„ã®å•†å“"
      normal:
        type: "array"
        description: "æ­£å¸¸åœ¨åº«ãƒ¬ãƒ™ãƒ«ã®å•†å“"
      excess:
        type: "array"
        description: "éå‰°åœ¨åº«ã®å•†å“"

  # ========================================
  # ç™ºæ³¨æ•°é‡è¨ˆç®—ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼
  # ========================================
  order_calculator:
    description: "æœ€é©ãªç™ºæ³¨æ•°é‡ã‚’è¨ˆç®—"
    inputs:
      items:
        type: "array"
      rules:
        type: "object"
        properties:
          category_a_months: "integer"
          category_b_months: "integer"
          category_c_months: "integer"
    
    logic: |
      function calculate(items, rules) {
        const MIN_ORDER_UNITS = {
          'A': 50,
          'B': 30,
          'C': 10
        };
        
        return items.map(item => {
          const monthlySales = item.fields['ğŸ“ˆ30æ—¥è²©å£²æ•° (æ•°å€¤)'] || 0;
          const currentStock = item.fields['ğŸ“Šç¾åœ¨åº«'] || 0;
          const pendingOrders = parseInt(item.fields['ğŸ“¦ç™ºæ³¨æ®‹æ•° (æ•°å€¤)']?.[0]?.text || '0');
          const unitCost = item.fields['ğŸ’¸åŸä¾¡ (é€šè²¨)'] || 0;
          
          // ã‚«ãƒ†ã‚´ãƒªåˆ¤å®š
          const category = monthlySales >= 30 ? 'A' : 
                          monthlySales >= 10 ? 'B' : 'C';
          
          // ç›®æ¨™åœ¨åº«æœˆæ•°
          const targetMonths = {
            'A': rules.category_a_months,
            'B': rules.category_b_months,
            'C': rules.category_c_months
          };
          
          // ç™ºæ³¨æ•°é‡è¨ˆç®—
          const targetStock = monthlySales * targetMonths[category];
          const orderQty = Math.max(0, targetStock - currentStock - pendingOrders);
          
          // æœ€å°ç™ºæ³¨å˜ä½ã§èª¿æ•´
          const minUnit = MIN_ORDER_UNITS[category];
          const adjustedQty = Math.ceil(orderQty / minUnit) * minUnit;
          
          return {
            record_id: item.record_id,
            product_name: item.fields['ğŸ“å•†å“å'][0].text,
            category: category,
            current_stock: currentStock,
            monthly_sales: monthlySales,
            pending_orders: pendingOrders,
            target_stock: targetStock,
            order_quantity: adjustedQty,
            unit_cost: unitCost,
            total_cost: adjustedQty * unitCost,
            reason: `åœ¨åº«${currentStock}å€‹, æœˆè²©${monthlySales}å€‹, ${category}ç´šå“`
          };
        }).filter(item => item.order_quantity > 0);
      }
    
    outputs:
      type: "array"
      description: "ç™ºæ³¨ææ¡ˆãƒªã‚¹ãƒˆ"

  # ========================================
  # æ—¥ä»˜è¨ˆç®—ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼
  # ========================================
  date_calculator:
    description: "æœŸé–“ã«åŸºã¥ã„ã¦æ—¥ä»˜ç¯„å›²ã‚’è¨ˆç®—"
    inputs:
      period:
        type: "enum"
        values: ["daily", "weekly", "monthly", "quarterly", "yearly"]
      target_date:
        type: "date"
    
    logic: |
      function calculateDateRange(period, targetDate) {
        const date = new Date(targetDate);
        let startDate, endDate;
        
        switch(period) {
          case 'daily':
            startDate = new Date(date);
            endDate = new Date(date);
            break;
            
          case 'weekly':
            const dayOfWeek = date.getDay();
            startDate = new Date(date);
            startDate.setDate(date.getDate() - dayOfWeek + 1); // Monday
            endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 6); // Sunday
            break;
            
          case 'monthly':
            startDate = new Date(date.getFullYear(), date.getMonth(), 1);
            endDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
            break;
            
          case 'quarterly':
            const quarter = Math.floor(date.getMonth() / 3);
            startDate = new Date(date.getFullYear(), quarter * 3, 1);
            endDate = new Date(date.getFullYear(), quarter * 3 + 3, 0);
            break;
            
          case 'yearly':
            startDate = new Date(date.getFullYear(), 0, 1);
            endDate = new Date(date.getFullYear(), 11, 31);
            break;
        }
        
        return {
          start_date: startDate.toISOString().split('T')[0],
          end_date: endDate.toISOString().split('T')[0]
        };
      }
    
    outputs:
      start_date:
        type: "date"
        description: "æœŸé–“é–‹å§‹æ—¥"
      end_date:
        type: "date"
        description: "æœŸé–“çµ‚äº†æ—¥"

  # ========================================
  # åœ¨åº«å½±éŸ¿åˆ†æãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼
  # ========================================
  stockout_impact:
    description: "åœ¨åº«åˆ‡ã‚Œã®å½±éŸ¿ã‚’åˆ†æ"
    inputs:
      product_id:
        type: "string"
      orders:
        type: "array"
    
    logic: |
      function analyzeImpact(productId, orders) {
        // å½±éŸ¿ã‚’å—ã‘ã‚‹é¡§å®¢ã®é›†è¨ˆ
        const uniqueCustomers = new Set();
        let totalRevenueLoss = 0;
        
        orders.forEach(order => {
          if (order.items.some(item => item.product_id === productId)) {
            uniqueCustomers.add(order.customer_id);
            const item = order.items.find(i => i.product_id === productId);
            totalRevenueLoss += item.quantity * item.unit_price;
          }
        });
        
        // ä»£æ›¿å•†å“ã®æ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        const substitutes = findSubstituteProducts(productId);
        
        return {
          affected_customers: Array.from(uniqueCustomers),
          customer_count: uniqueCustomers.size,
          revenue_impact: totalRevenueLoss,
          substitute_products: substitutes
        };
      }
      
      function findSubstituteProducts(productId) {
        // ã‚«ãƒ†ã‚´ãƒªã‚„å±æ€§ã«åŸºã¥ã„ã¦ä»£æ›¿å•†å“ã‚’æ¤œç´¢
        // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€å•†å“ãƒã‚¹ã‚¿ã‹ã‚‰é¡ä¼¼å•†å“ã‚’æ¤œç´¢
        return [
          { id: 'alt1', name: 'ä»£æ›¿å•†å“1', stock: 50 },
          { id: 'alt2', name: 'ä»£æ›¿å•†å“2', stock: 30 }
        ];
      }

# ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼å®šç¾©
validators:
  inventory_adjustment:
    description: "åœ¨åº«èª¿æ•´ã®å¦¥å½“æ€§ã‚’æ¤œè¨¼"
    rules:
      - name: "negative_stock_check"
        condition: |
          (adjustment_type === "decrease" || adjustment_type === "transfer") 
          && quantity > current_stock
        error: "åœ¨åº«æ•°é‡ãŒä¸è¶³ã—ã¦ã„ã¾ã™"
      
      - name: "quantity_range_check"
        condition: |
          quantity <= 0 || quantity > 10000
        error: "èª¿æ•´æ•°é‡ã¯1ï½10000ã®ç¯„å›²ã§æŒ‡å®šã—ã¦ãã ã•ã„"
      
      - name: "reason_required"
        condition: |
          !reason || reason.trim().length < 5
        error: "èª¿æ•´ç†ç”±ã‚’5æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„"

# ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼å®šç¾©
formatters:
  inventory_daily_report:
    template: |
      ğŸ“Š åœ¨åº«ç®¡ç†æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆ
      æ—¥ä»˜: {{date}}
      
      ğŸš¨ ç·Šæ€¥å¯¾å¿œå¿…è¦ ({{critical.length}}ä»¶)
      {{#each critical}}
      ãƒ»{{name}}: åœ¨åº«{{stock}}å€‹ ({{daysOfStock}}æ—¥åˆ†)
      {{/each}}
      
      âš ï¸ è¦æ³¨æ„å•†å“ ({{warning.length}}ä»¶)
      {{#each warning}}
      ãƒ»{{name}}: åœ¨åº«{{stock}}å€‹ ({{daysOfStock}}æ—¥åˆ†)
      {{/each}}
      
      ğŸ“¦ éå‰°åœ¨åº« ({{excess.length}}ä»¶)
      {{#each excess}}
      ãƒ»{{name}}: åœ¨åº«{{stock}}å€‹ (æœˆè²©{{sales}}å€‹)
      {{/each}}
      
      ğŸ“ˆ ã‚µãƒãƒªãƒ¼
      ãƒ»å…¨å•†å“æ•°: {{total_products}}
      ãƒ»é©æ­£åœ¨åº«ç‡: {{healthy_percentage}}%
      ãƒ»è¦å¯¾å¿œå•†å“: {{action_required}}ä»¶

  purchase_order_summary:
    template: |
      ğŸ“‹ ç™ºæ³¨æ›¸ã‚µãƒãƒªãƒ¼
      ç™ºæ³¨ç•ªå·: {{po_number}}
      ç™ºæ³¨æ—¥: {{order_date}}
      
      å•†å“æƒ…å ±:
      ãƒ»å•†å“å: {{product_name}}
      ãƒ»ç™ºæ³¨æ•°é‡: {{quantity}}å€‹
      ãƒ»å˜ä¾¡: Â¥{{unit_price}}
      ãƒ»åˆè¨ˆ: Â¥{{total_amount}}
      
      ç´æœŸ: {{delivery_date}}
      æ”¯æ‰•æ¡ä»¶: {{payment_terms}}
      
      å‚™è€ƒ: {{notes}}

# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
utilities:
  generate_po_number:
    description: "ç™ºæ³¨ç•ªå·ã‚’ç”Ÿæˆ"
    logic: |
      function generatePONumber() {
        const date = new Date();
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const sequence = String(Math.floor(Math.random() * 100)).padStart(2, '0');
        return `PO-${year}${month}${day}${sequence}`;
      }
  
  add_days:
    description: "æ—¥ä»˜ã«æ—¥æ•°ã‚’åŠ ç®—"
    logic: |
      function addDays(dateStr, days) {
        const date = new Date(dateStr);
        date.setDate(date.getDate() + days);
        return date.toISOString().split('T')[0];
      }
  
  format_currency:
    description: "é€šè²¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"
    logic: |
      function formatCurrency(amount, currency = 'JPY') {
        return new Intl.NumberFormat('ja-JP', {
          style: 'currency',
          currency: currency
        }).format(amount);
      }